<RESOURCE_PROFILE>
	<HEADER>
		<RESOURCE_IDENTIFIER value="" />
		<RESOURCE_TYPE value="TransformationRuleDSResourceType" />
		<RESOURCE_KIND value="TransformationRuleDSResources" />
		<RESOURCE_URI value="" />
		<DATE_OF_CREATION value="2024-03-05T11:23:00+00:00" />
	</HEADER>
	<BODY>
		<CONFIGURATION>
			<SOURCE_METADATA_FORMAT interpretation="cleaned" layout="store" name="odf" />
			<SINK_METADATA_FORMAT name="odf_hbase" />
			<IMPORTED />
			<SCRIPT>
				<TITLE>xslt_base2oaf_hadoop</TITLE>
				<CODE>
					<xsl:stylesheet xmlns:oaire="http://namespace.openaire.eu/schema/oaire/" xmlns:dateCleaner="http://eu/dnetlib/transform/dateISO"
						xmlns:base_dc="http://oai.base-search.net/base_dc/"
						xmlns:datacite="http://datacite.org/schema/kernel-4" xmlns:dr="http://www.driver-repository.eu/namespace/dr" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:vocabulary="http://eu/dnetlib/transform/clean" xmlns:oaf="http://namespace.openaire.eu/oaf"
						xmlns:oai="http://www.openarchives.org/OAI/2.0/" xmlns:dri="http://www.driver-repository.eu/namespace/dri" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:dc="http://purl.org/dc/elements/1.1/"
						exclude-result-prefixes="xsl vocabulary dateCleaner base_dc" version="2.0">
						<xsl:param name="varOfficialName" />
						<xsl:param name="varDataSourceId" />
						<xsl:param name="varFP7" select="'corda_______::'" />
						<xsl:param name="varH2020" select="'corda__h2020::'" />
						<xsl:param name="repoCode" select="substring-before(//*[local-name() = 'header']/*[local-name()='recordIdentifier'], ':')" />
						<xsl:param name="index" select="0" />
						<xsl:param name="transDate" select="current-dateTime()" />

						<xsl:template name="terminate">
							<xsl:message terminate="yes">
								record is not compliant, transformation is interrupted.
							</xsl:message>
						</xsl:template>

						<xsl:template match="/">
							<record>
								<xsl:apply-templates select="//*[local-name() = 'header']" />


<!-- TO EVALUATE
base_dc:authod_id
base_dc:authod_id/base_dc:creator_id
base_dc:authod_id/base_dc:creator_name
-->

<!-- NOT USED 
base_dc:global_id (I used oai:identifier)
base_dc:collection/text()
base_dc:collection/@ror_id
base_dc:continent
base_dc:country
base_dc:year (I used dc:date)
dc:coverage
dc:language (I used base_dc:lang)
base_dc:link (I used dc:identifier)
-->


								<xsl:variable name="varBaseNormType" select="vocabulary:clean(//base_dc:typenorm, 'base:normalized_types')" />
								

								<metadata>
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:title" />
										<xsl:with-param name="targetElement" select="'dc:title'" />
									</xsl:call-template>

									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:creator/replace(., '^(.*)\|.*$', '$1')" />
										<xsl:with-param name="targetElement" select="'dc:creator'" />
									</xsl:call-template>

									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:contributor" />
										<xsl:with-param name="targetElement" select="'dc:contributor'" />
									</xsl:call-template>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:description" />
										<xsl:with-param name="targetElement" select="'dc:description'" />
									</xsl:call-template>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:subject" />
										<xsl:with-param name="targetElement" select="'dc:subject'" />
									</xsl:call-template>
									
									<!-- TODO: I'm not sure if this is the correct encoding -->
									<xsl:for-each select="//base_dc:classcode|//base_dc:autoclasscode">
										<dc:subject><xsl:value-of select="concat(@type, ':', .)" /></dc:subject>
									</xsl:for-each>
									<!-- END TODO -->
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:publisher" />
										<xsl:with-param name="targetElement" select="'dc:publisher'" />
									</xsl:call-template>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:format" />
										<xsl:with-param name="targetElement" select="'dc:format'" />
									</xsl:call-template>
									
									<dc:type>
										<xsl:value-of select="$varBaseNormType" />
									</dc:type>
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:type" />
										<xsl:with-param name="targetElement" select="'dc:type'" />
									</xsl:call-template>
									
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:source" />
										<xsl:with-param name="targetElement" select="'dc:source'" />
									</xsl:call-template>
									
									<dc:language>
										<xsl:value-of select="vocabulary:clean( //base_dc:lang, 'dnet:languages')" />
									</dc:language>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:rights" />
										<xsl:with-param name="targetElement" select="'dc:rights'" />
									</xsl:call-template>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:relation" />
										<xsl:with-param name="targetElement" select="'dc:relation'" />
									</xsl:call-template>
									
									<xsl:if test="not(//dc:identifier[starts-with(., 'http')])">
										<xsl:call-template name="terminate" />
									</xsl:if>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:identifier[starts-with(., 'http')]" />
										<xsl:with-param name="targetElement" select="'dc:identifier'" />
									</xsl:call-template>
									
									<xsl:for-each select="//dc:relation">
										<xsl:if test="matches(normalize-space(.), '(info:eu-repo/grantagreement/ec/fp7/)(\d\d\d\d\d\d)(.*)', 'i')">
											<oaf:projectid>
												<xsl:value-of select="concat($varFP7, replace(normalize-space(.), '(info:eu-repo/grantagreement/ec/fp7/)(\d\d\d\d\d\d)(.*)', '$2', 'i'))" />
											</oaf:projectid>
										</xsl:if>
										<xsl:if test="matches(normalize-space(.), '(info:eu-repo/grantagreement/ec/h2020/)(\d\d\d\d\d\d)(.*)', 'i')">
											<oaf:projectid>
												<xsl:value-of select="concat($varH2020, replace(normalize-space(.), '(info:eu-repo/grantagreement/ec/h2020/)(\d\d\d\d\d\d)(.*)', '$2', 'i'))" />
											</oaf:projectid>
										</xsl:if>
									</xsl:for-each>
									
									<oaf:accessrights>
										<xsl:choose>
											<xsl:when test="//base_dc:oa[.='1']">OPEN</xsl:when>
											<xsl:when test="//base_dc:rightsnorm">
												<xsl:value-of select="vocabulary:clean(//base_dc:rightsnorm, 'dnet:access_modes')" />
											</xsl:when>
											<xsl:when test="//dc:rights">
												<xsl:value-of select="vocabulary:clean( //dc:rights, 'dnet:access_modes')" />
											</xsl:when>
											<xsl:otherwise>UNKNOWN</xsl:otherwise>
										</xsl:choose>
									</oaf:accessrights>
									
									<xsl:for-each select="//base_dc:doi">
										<oaf:identifier>
											<xsl:attribute name="identifierType" select="'doi'" />
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>
									
									<oaf:hostedBy>
										<xsl:attribute name="name">
											<xsl:value-of select="//base_dc:collname" />
										</xsl:attribute>
										<xsl:attribute name="id">
											<xsl:value-of select="concat('opendoar____::', //base_dc:collection/@opendoar_id)" />
										</xsl:attribute>
									</oaf:hostedBy>
									
									<oaf:collectedFrom>
										<xsl:attribute name="name">
											<xsl:value-of select="$varOfficialName" />
										</xsl:attribute>
										<xsl:attribute name="id">
											<xsl:value-of select="$varDataSourceId" />
										</xsl:attribute>
									</oaf:collectedFrom>
									
									<oaf:dateAccepted>
										<xsl:value-of select="dateCleaner:dateISO( //dc:date[1] )" />
									</oaf:dateAccepted>
									
									<xsl:if test="//dc:relation[starts-with(., 'http')] and //base_dc:oa[.='1']">
										<oaf:fulltext>
											<xsl:value-of select="//dc:relation[starts-with(., 'http')]" />
										</oaf:fulltext>
									</xsl:if>
									
									<oaf:identifier>
										<xsl:attribute name="identifierType" select="'oai-original'" />
										<xsl:value-of
											select="//*[local-name() = 'about']/*[local-name() = 'provenance']//*[local-name() = 'originDescription' and not(./*[local-name() = 'originDescription'])]/*[local-name() = 'identifier']" />
									</oaf:identifier>

									<!-- TODO: ADD VOCABULARY TERMS -->
									<dr:CobjCategory>
										<xsl:variable name="varCobjCategory" select="vocabulary:clean($varBaseNormType, 'dnet:publication_resource')" />
										<xsl:variable name="varSuperType" select="vocabulary:clean($varCobjCategory, 'dnet:result_typologies')" />
										<xsl:attribute name="type" select="$varSuperType" />
										<xsl:value-of select="$varCobjCategory" />
									</dr:CobjCategory>
									<!-- END TODO -->
									
									<!-- TODO CONTINUE HERE -->
									
									
									<xsl:variable name="varRefereedConvt"
										select="for $i in (//dc:type, //dc:description, //oai:setSpec) return vocabulary:clean( normalize-space($i), 'dnet:review_levels')" />
									<xsl:variable name="varRefereedIdntf"
										select="(//*[string(node-name(.)) = 'dc:identifier' and matches(lower-case(.), '(^|.*[\.\-_/\s\(\)%\d#])pre[\.\-_/\s\(\)%\d#]?prints?([\.\-_/\s\(\)%\d#].*)?$')][count(//dc:identifier) = 1]/'0002', //*[string(node-name(.)) = 'dc:identifier' and matches(lower-case(.), '(^|.*[\.\-_/\s\(\)%\d#])refereed([\.\-_/\s\(\)\d%\d#].*)?$')]/'0001', //*[string(node-name(.)) = 'dc:identifier' and matches(lower-case(.), '.*-peer-reviewed-(fulltext-)?article-.*')]/'0001')" />
									<xsl:variable name="varRefereedSourc"
										select="//*[string(node-name(.)) = ('dc:source', 'dc:publisher') and matches(lower-case(.), '^(.*\s)?pre[\s\-_]*prints?([\s\.,].*)?$')]/'0002'" />
									<xsl:variable name="varRefereedDescr"
										select="(//dc:description[matches(lower-case(.), '.*(this\s*book|this\s*volume|it)\s*constitutes\s*the\s*(thoroughly\s*)?refereed') or matches(lower-case(.), '.*peer[\.\-_/\s\(\)]?review\s*under\s*responsibility\s*of.*') or matches(lower-case(.), '(this|a)\s*(article|preprint)\s*(has\s*been\s*)?(peer[\-\s]*)?reviewed\s*and\s*recommended\s*by\s*peer[\-\s]*community')]/'0001', //dc:description[matches(., '^version\s*(préliminaire.*|preliminary.*|0$)')]/'0002')" />
									<xsl:variable name="varRefereedTitle"
										select="(//dc:title[matches(lower-case(.), '.*\[.*peer[\s\-\._]*review\s*:.*\]\s*$')]/'0001', //dc:title[matches(lower-case(.), '.*\(\s*pre[\s\-\._]*prints?\s*\)\s*$')]/'0002')" />
									<xsl:variable name="varRefereedSubjt"
										select="(//dc:subject[matches(lower-case(.), '^\s*refereed\s*$')][//oaf:datasourceprefix = 'narcis______']/'0001', //dc:subject[matches(lower-case(.), '^\s*no[nt].{0,3}refereed\s*$')][//oaf:datasourceprefix = 'narcis______']/'0002')" />
									
									<xsl:variable name="varRefereed" select="($varRefereedConvt, $varRefereedIdntf, $varRefereedSourc, $varRefereedDescr, $varRefereedTitle, $varRefereedSubjt)" />
									
									<xsl:choose>
										<xsl:when test="count($varRefereed[. = '0001']) &gt; 0">
											<oaf:refereed>
												<xsl:value-of select="'0001'" />
											</oaf:refereed>
										</xsl:when>
										<xsl:when test="count($varRefereed[. = '0002']) &gt; 0">
											<oaf:refereed>
												<xsl:value-of select="'0002'" />
											</oaf:refereed>
										</xsl:when>
									</xsl:choose>
									
									<xsl:variable name="varKnownFileEndings"
										select="('.bmp', '.doc', '.docx', '.epub', '.flv', '.jpeg', '.jpg', '.m4v', '.mp4', '.mpg', '.odp', '.pdf', '.png', '.ppt', '.tiv', '.txt', '.xls', '.xlsx', '.zip')" /><!-- regular expression 
										for DOIs reduced here - letters like less-than and quotation marks don't work in matches, use identiferExtract when enabled -->
									
									
									<xsl:variable name="varIdHdl" select="distinct-values(//dc:identifier[starts-with(., 'http') and contains(., '://hdl.handle.net/')]/substring-after(., 'hdl.handle.net/'))" />
									<xsl:for-each select="$varIdHdl">
										<oaf:identifier>
											<xsl:attribute name="identifierType" select="'handle'" />
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>
									
									<xsl:variable name="varIdUrn" select="distinct-values(//dc:identifier[starts-with(., 'urn:nbn:nl:') or starts-with(., 'URN:NBN:NL:')])" />
									<xsl:for-each select="$varIdUrn">
										<oaf:identifier>
											<xsl:attribute name="identifierType" select="'urn'" />
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each><!-- the 2 comparison orders needed to work also for URL encoded baseURLs or item URLs -->
									
									<xsl:variable name="varOrigBaseUrl"
										select="//*[local-name() = 'about']/*[local-name() = 'provenance']//*[local-name() = 'originDescription' and not(./*[local-name() = 'originDescription'])]/*[local-name() = 'baseURL']" />
									<xsl:variable name="varIdLdpg"
										select="distinct-values(//dc:identifier[(contains(substring-after(., '://'), '/') and contains($varOrigBaseUrl, substring-before(substring-after(., '://'), '/'))) or (contains(substring-after(., '://'), ':') and contains($varOrigBaseUrl, substring-before(substring-after(., '://'), ':')))][not(replace(lower-case(.), '.*(\.[a-z]*)$', '$1') = $varKnownFileEndings)])" />
									<xsl:for-each select="$varIdLdpg">
										<oaf:identifier>
											<xsl:attribute name="identifierType" select="'landingPage'" />
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>
									
									<xsl:variable name="varIdUrl"
										select="distinct-values(//dc:identifier[starts-with(., 'http')][not(contains(., '://dx.doi.org/') or contains(., '://doi.org/') or contains(., '://hdl.handle.net/'))][count(index-of($varIdLdpg, .)) = 0])" />
									<xsl:for-each select="$varIdUrl">
										<oaf:identifier>
											<xsl:attribute name="identifierType" select="'url'" />
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>
									
								</metadata>
								<xsl:copy-of select="//*[local-name() = 'about']" />
							</record>
						</xsl:template>

						<xsl:template name="allElements">
							<xsl:param name="sourceElement" />
							<xsl:param name="targetElement" />
							<xsl:for-each select="$sourceElement">
								<xsl:element name="{$targetElement}">
									<xsl:value-of select="normalize-space(.)" />
								</xsl:element>
							</xsl:for-each>
						</xsl:template>

						<xsl:template match="//*[local-name() = 'header']">
							<xsl:if test="//oai:header/@status='deleted'">
								<xsl:call-template name="terminate" />
							</xsl:if>
							<xsl:copy>
								<xsl:apply-templates select="node()|@*" />
								<xsl:element name="dr:dateOfTransformation">
									<xsl:value-of select="$transDate" />
								</xsl:element>
							</xsl:copy>
						</xsl:template>

						<xsl:template match="node()|@*">
							<xsl:copy>
								<xsl:apply-templates select="node()|@*" />
							</xsl:copy>
						</xsl:template>
					</xsl:stylesheet>
				</CODE>
			</SCRIPT>
		</CONFIGURATION>
		<STATUS />
		<SECURITY_PARAMETERS />
	</BODY>
</RESOURCE_PROFILE>