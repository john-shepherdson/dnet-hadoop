<RESOURCE_PROFILE>
	<HEADER>
		<RESOURCE_IDENTIFIER value="" />
		<RESOURCE_TYPE value="TransformationRuleDSResourceType" />
		<RESOURCE_KIND value="TransformationRuleDSResources" />
		<RESOURCE_URI value="" />
		<DATE_OF_CREATION value="2024-03-05T11:23:00+00:00" />
	</HEADER>
	<BODY>
		<CONFIGURATION>
			<SOURCE_METADATA_FORMAT interpretation="cleaned" layout="store" name="dc" />
			<SINK_METADATA_FORMAT name="oaf_hbase" />
			<IMPORTED />
			<SCRIPT>
				<TITLE>xslt_base2oaf_hadoop</TITLE>
				<CODE>
					<xsl:stylesheet xmlns:oaire="http://namespace.openaire.eu/schema/oaire/" xmlns:dateCleaner="http://eu/dnetlib/transform/dateISO"
						xmlns:base_dc="http://oai.base-search.net/base_dc/"
						xmlns:datacite="http://datacite.org/schema/kernel-4" xmlns:dr="http://www.driver-repository.eu/namespace/dr" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:vocabulary="http://eu/dnetlib/transform/clean" xmlns:oaf="http://namespace.openaire.eu/oaf"
						xmlns:oai="http://www.openarchives.org/OAI/2.0/" xmlns:dri="http://www.driver-repository.eu/namespace/dri" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:dc="http://purl.org/dc/elements/1.1/"
						exclude-result-prefixes="xsl vocabulary dateCleaner base_dc" version="2.0">
						<xsl:param name="varOfficialName" />
						<xsl:param name="varDataSourceId" />
						<xsl:param name="varFP7" select="'corda_______::'" />
						<xsl:param name="varH2020" select="'corda__h2020::'" />
						<xsl:param name="repoCode" select="substring-before(//*[local-name() = 'header']/*[local-name()='recordIdentifier'], ':')" />
						<xsl:param name="index" select="0" />
						<xsl:param name="transDate" select="current-dateTime()" />

						<xsl:template name="terminate">
							<xsl:message terminate="yes">
								record is not compliant, transformation is interrupted.
							</xsl:message>
						</xsl:template>

						<xsl:template match="/">
							<record>
								<xsl:apply-templates select="//*[local-name() = 'header']" />


<!-- TO EVALUATE
base_dc:authod_id
base_dc:authod_id/base_dc:creator_id
base_dc:authod_id/base_dc:creator_name

example:

<dc:creator>ALBU, Svetlana</dc:creator>

<base_dc:authod_id>
	<base_dc:creator_name>ALBU, Svetlana</base_dc:creator_name>
    <base_dc:creator_id>https://orcid.org/0000-0002-8648-950X</base_dc:creator_id>
</base_dc:authod_id>
-->

<!-- NOT USED 
base_dc:global_id (I used oai:identifier)
base_dc:collection/text()

base_dc:continent
base_dc:year (I used dc:date)
dc:coverage
dc:language (I used base_dc:lang)
base_dc:link (I used dc:identifier)
-->


								<xsl:variable name="varBaseNormType" select="vocabulary:clean(//base_dc:typenorm, 'base:normalized_types')" />
								

								<metadata>
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:title" />
										<xsl:with-param name="targetElement" select="'dc:title'" />
									</xsl:call-template>

									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:creator/replace(., '^(.*)\|.*$', '$1')" />
										<xsl:with-param name="targetElement" select="'dc:creator'" />
									</xsl:call-template>

									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:contributor" />
										<xsl:with-param name="targetElement" select="'dc:contributor'" />
									</xsl:call-template>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:description" />
										<xsl:with-param name="targetElement" select="'dc:description'" />
									</xsl:call-template>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:subject" />
										<xsl:with-param name="targetElement" select="'dc:subject'" />
									</xsl:call-template>
									
									<!-- TODO: I'm not sure if this is the correct encoding -->
									<xsl:for-each select="//base_dc:classcode|//base_dc:autoclasscode">
										<dc:subject><xsl:value-of select="concat(@type, ':', .)" /></dc:subject>
									</xsl:for-each>
									<!-- END TODO -->
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:publisher" />
										<xsl:with-param name="targetElement" select="'dc:publisher'" />
									</xsl:call-template>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:format" />
										<xsl:with-param name="targetElement" select="'dc:format'" />
									</xsl:call-template>
									
									<dc:type>
										<xsl:value-of select="$varBaseNormType" />
									</dc:type>
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:type" />
										<xsl:with-param name="targetElement" select="'dc:type'" />
									</xsl:call-template>
									
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:source" />
										<xsl:with-param name="targetElement" select="'dc:source'" />
									</xsl:call-template>
									
									<dc:language>
										<xsl:value-of select="vocabulary:clean( //base_dc:lang, 'dnet:languages')" />
									</dc:language>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:rights" />
										<xsl:with-param name="targetElement" select="'dc:rights'" />
									</xsl:call-template>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:relation" />
										<xsl:with-param name="targetElement" select="'dc:relation'" />
									</xsl:call-template>
									
									<xsl:if test="not(//dc:identifier[starts-with(., 'http')])">
										<xsl:call-template name="terminate" />
									</xsl:if>
									
									<xsl:call-template name="allElements">
										<xsl:with-param name="sourceElement" select="//dc:identifier[starts-with(., 'http')]" />
										<xsl:with-param name="targetElement" select="'dc:identifier'" />
									</xsl:call-template>
									
									<xsl:for-each select="//dc:relation">
										<xsl:if test="matches(normalize-space(.), '(info:eu-repo/grantagreement/ec/fp7/)(\d\d\d\d\d\d)(.*)', 'i')">
											<oaf:projectid>
												<xsl:value-of select="concat($varFP7, replace(normalize-space(.), '(info:eu-repo/grantagreement/ec/fp7/)(\d\d\d\d\d\d)(.*)', '$2', 'i'))" />
											</oaf:projectid>
										</xsl:if>
										<xsl:if test="matches(normalize-space(.), '(info:eu-repo/grantagreement/ec/h2020/)(\d\d\d\d\d\d)(.*)', 'i')">
											<oaf:projectid>
												<xsl:value-of select="concat($varH2020, replace(normalize-space(.), '(info:eu-repo/grantagreement/ec/h2020/)(\d\d\d\d\d\d)(.*)', '$2', 'i'))" />
											</oaf:projectid>
										</xsl:if>
									</xsl:for-each>

									<dr:CobjCategory>
										<xsl:variable name="varCobjCategory" select="vocabulary:clean($varBaseNormType, 'dnet:publication_resource')" />
										<xsl:variable name="varSuperType" select="vocabulary:clean($varCobjCategory, 'dnet:result_typologies')" />
										<xsl:attribute name="type" select="$varSuperType" />
										<xsl:value-of select="$varCobjCategory" />
									</dr:CobjCategory>
									
									<oaf:accessrights>
										<xsl:choose>
											<xsl:when test="//base_dc:oa[.='1']">OPEN</xsl:when>
											<xsl:when test="//base_dc:rightsnorm">
												<xsl:value-of select="vocabulary:clean(//base_dc:rightsnorm, 'dnet:access_modes')" />
											</xsl:when>
											<xsl:when test="//dc:rights">
												<xsl:value-of select="vocabulary:clean( //dc:rights, 'dnet:access_modes')" />
											</xsl:when>
											<xsl:otherwise>UNKNOWN</xsl:otherwise>
										</xsl:choose>
									</oaf:accessrights>
									
									<xsl:for-each select="//base_dc:doi">
										<oaf:identifier identifierType="doi">
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>

									<xsl:for-each select="distinct-values(//dc:identifier[starts-with(., 'http') and (not(contains(., '://dx.doi.org/') or contains(., '://doi.org/') or contains(., '://hdl.handle.net/')))])">
										<oaf:identifier identifierType="url">
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>

									<xsl:for-each select="distinct-values(//dc:identifier[starts-with(., 'http') and contains(., '://hdl.handle.net/')]/substring-after(., 'hdl.handle.net/'))">
										<oaf:identifier identifierType="handle">
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>									

									<xsl:for-each select="distinct-values(//dc:identifier[starts-with(., 'urn:nbn:nl:') or starts-with(., 'URN:NBN:NL:')])">
										<oaf:identifier identifierType='urn'>
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>
									
									<oaf:identifier identifierType="oai-original">
										<xsl:value-of
											select="//*[local-name() = 'about']/*[local-name() = 'provenance']//*[local-name() = 'originDescription' and not(./*[local-name() = 'originDescription'])]/*[local-name() = 'identifier']" />
									</oaf:identifier>
									
									<oaf:hostedBy>
										<xsl:attribute name="name">
											<xsl:value-of select="//base_dc:collname" />
										</xsl:attribute>
										<xsl:attribute name="id">
											<xsl:value-of select="concat('opendoar____::', //base_dc:collection/@opendoar_id)" />
										</xsl:attribute>
									</oaf:hostedBy>
									
									<oaf:collectedFrom>
										<xsl:attribute name="name">
											<xsl:value-of select="$varOfficialName" />
										</xsl:attribute>
										<xsl:attribute name="id">
											<xsl:value-of select="$varDataSourceId" />
										</xsl:attribute>
									</oaf:collectedFrom>
									
									<oaf:dateAccepted>
										<xsl:value-of select="dateCleaner:dateISO( //dc:date[1] )" />
									</oaf:dateAccepted>
									
									<xsl:if test="//base_dc:oa[.='1']">
										<xsl:for-each select="//dc:relation[starts-with(., 'http')]">
											<oaf:fulltext>
												<xsl:value-of select="normalize-space(.)" />
											</oaf:fulltext>
										</xsl:for-each>
									</xsl:if>
									
									<xsl:for-each select="//base_dc:collection/@ror_id">
										<oaf:relation relType="resultOrganization"
										 	subRelType="affiliation"
										 	relClass="hasAuthorInstitution"
											targetType="organization">
											<xsl:choose>
												<xsl:when test="contains(.,'https://ror.org/')">
													<xsl:value-of select="concat('ror_________::', normalize-space(.))" />
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="concat('ror_________::https://ror.org/', normalize-space(.))" />
												</xsl:otherwise>
											</xsl:choose>
										</oaf:relation>										
									</xsl:for-each>

									<xsl:for-each select="//base_dc:country">
										<oaf:country><xsl:value-of select="vocabulary:clean(., 'dnet:countries')" /></oaf:country>
									</xsl:for-each>
									
								</metadata>
								<xsl:copy-of select="//*[local-name() = 'about']" />
							</record>
						</xsl:template>

						<xsl:template name="allElements">
							<xsl:param name="sourceElement" />
							<xsl:param name="targetElement" />
							<xsl:for-each select="$sourceElement">
								<xsl:element name="{$targetElement}">
									<xsl:value-of select="normalize-space(.)" />
								</xsl:element>
							</xsl:for-each>
						</xsl:template>

						<xsl:template match="//*[local-name() = 'header']">
							<xsl:if test="//oai:header/@status='deleted'">
								<xsl:call-template name="terminate" />
							</xsl:if>
							<xsl:copy>
								<xsl:apply-templates select="node()|@*" />
								<xsl:element name="dr:dateOfTransformation">
									<xsl:value-of select="$transDate" />
								</xsl:element>
							</xsl:copy>
						</xsl:template>

						<xsl:template match="node()|@*">
							<xsl:copy>
								<xsl:apply-templates select="node()|@*" />
							</xsl:copy>
						</xsl:template>
					</xsl:stylesheet>
				</CODE>
			</SCRIPT>
		</CONFIGURATION>
		<STATUS />
		<SECURITY_PARAMETERS />
	</BODY>
</RESOURCE_PROFILE>