<RESOURCE_PROFILE>
	<HEADER>
		<RESOURCE_IDENTIFIER value="" />
		<RESOURCE_TYPE value="TransformationRuleDSResourceType" />
		<RESOURCE_KIND value="TransformationRuleDSResources" />
		<RESOURCE_URI value="" />
		<DATE_OF_CREATION value="2024-03-05T11:23:00+00:00" />
	</HEADER>
	<BODY>
		<CONFIGURATION>
			<SOURCE_METADATA_FORMAT interpretation="cleaned" layout="store" name="odf" />
			<SINK_METADATA_FORMAT name="odf_hbase" />
			<IMPORTED />
			<SCRIPT>
				<TITLE>xslt_base2oaf_hadoop</TITLE>
				<CODE>
					<xsl:stylesheet xmlns:oaire="http://namespace.openaire.eu/schema/oaire/" xmlns:dateCleaner="http://eu/dnetlib/transform/dateISO" xmlns:base_dc="http://oai.base-search.net/base_dc/"
						xmlns:datacite="http://datacite.org/schema/kernel-4" xmlns:dr="http://www.driver-repository.eu/namespace/dr" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:vocabulary="http://eu/dnetlib/transform/clean" xmlns:oaf="http://namespace.openaire.eu/oaf"
						xmlns:oai="http://www.openarchives.org/OAI/2.0/" xmlns:dri="http://www.driver-repository.eu/namespace/dri" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:dc="http://purl.org/dc/elements/1.1/"
						exclude-result-prefixes="xsl vocabulary dateCleaner base_dc" version="2.0">
						<xsl:param name="varOfficialName" />
						<xsl:param name="varDataSourceId" />
						<xsl:param name="varFP7" select="'corda_______::'" />
						<xsl:param name="varH2020" select="'corda__h2020::'" />
						<xsl:param name="repoCode" select="substring-before(//*[local-name() = 'header']/*[local-name()='recordIdentifier'], ':')" />
						<xsl:param name="index" select="0" />
						<xsl:param name="transDate" select="current-dateTime()" />

						<xsl:template name="terminate">
							<xsl:message terminate="yes">
								record is not compliant, transformation is interrupted.
							</xsl:message>
						</xsl:template>

						<xsl:template match="/">
							<record>
								<xsl:apply-templates select="//*[local-name() = 'header']" />


								<!-- NOT USED 
									base_dc:global_id (I used oai:identifier) 
									base_dc:collection/text() 
									base_dc:continent 
									base_dc:country  
									dc:coverage
									dc:language (I used base_dc:lang) 
									base_dc:link (I used dc:identifier)
								 -->


								<xsl:variable name="varBaseNormType" select="vocabulary:clean(//base_dc:typenorm, 'base:normalized_types')" />


								<metadata>
									<datacite:resource>

										<xsl:for-each select="//base_dc:doi">
											<datacite:identifier identifierType="DOI">
												<xsl:value-of select="." />
											</datacite:identifier>
										</xsl:for-each>

										<datacite:alternateIdentifiers>
											<xsl:for-each
												select="distinct-values(//dc:identifier[starts-with(., 'http')][not(contains(., '://dx.doi.org/') or contains(., '://doi.org/') or contains(., '://hdl.handle.net/'))][count(index-of($varIdLdpg, .)) = 0])">
												<datacite:identifier alternateIdentifierType="url">
													<xsl:value-of select="." />
												</datacite:identifier>
											</xsl:for-each>

											<xsl:for-each select="distinct-values(//dc:identifier[starts-with(., 'http') and contains(., '://hdl.handle.net/')]/substring-after(., 'hdl.handle.net/'))">
												<datacite:identifier alternateIdentifierType="handle">
													<xsl:value-of select="." />
												</datacite:identifier>
											</xsl:for-each>

											<xsl:for-each select="distinct-values(//dc:identifier[starts-with(., 'urn:nbn:nl:') or starts-with(., 'URN:NBN:NL:')])">
												<datacite:identifier alternateIdentifierType='urn'>
													<xsl:value-of select="." />
												</datacite:identifier>
											</xsl:for-each>

											<datacite:identifier alternateIdentifierType="oai-original">
												<xsl:value-of
													select="//*[local-name() = 'about']/*[local-name() = 'provenance']//*[local-name() = 'originDescription' and not(./*[local-name() = 'originDescription'])]/*[local-name() = 'identifier']" />
											</datacite:identifier>
										</datacite:alternateIdentifiers>

										<datacite:relatedIdentifiers />


										<datacite:resourceType xs:anyURI="http://purl.org/coar/TODO">TODO</datacite:resourceType>

										<datacite:titles>
											<xsl:for-each select="//dc:title">
												<datacite:title>
													<xsl:value-of select="normalize-space(.)" />
												</datacite:title>
											</xsl:for-each>
										</datacite:titles>

										<datacite:creators>
											<xsl:for-each select="//dc:creator">
												<xsl:variable name="author" select="normalize-space(.)" />
												<datacite:creator>
													<datacite:creatorName>
														<xsl:value-of select="$author" />
													</datacite:creatorName>
													<xsl:for-each select="//base_dc:authod_id[normalize-space(./base_dc:creator_name = $author]/base_dc:creator_id ">
														<xsl:if test="contains(.,'https://orcid.org/')">
															<nameIdentifier schemeURI="https://orcid.org/" nameIdentifierScheme="ORCID">
																<xsl:value-of select="substring-after(., 'https://orcid.org/')" />
															</nameIdentifier>
														</xsl:if>
													</xsl:for-each>
												</datacite:creator>
											</xsl:for-each>
										</datacite:creators>

										<datacite:contributors>
											<xsl:for-each select="//dc:contributor">
												<datacite:contributor>
													<datacite:contributorName>
														<xsl:value-of select="normalize-space(.)" />
													</datacite:contributorName>
												</datacite:contributor>
											</xsl:for-each>
										</datacite:contributors>

										<datacite:descriptions>
											<xsl:for-each select="//dc:description">
												<datacite:description descriptionType="Abstract">
													<xsl:value-of select="normalize-space(.)" />
												</datacite:description>
											</xsl:for-each>
										</datacite:descriptions>

										<datacite:subjects>
											<xsl:for-each select="//dc:subject">
												<datacite:subject>
													<xsl:value-of select="normalize-space(.)" />
												</datacite:subject>
											</xsl:for-each>
											
											<xsl:for-each select="//base_dc:classcode|//base_dc:autoclasscode">
												<datacite:subject subjectScheme="{@type}" classificationCode="{normalize-space(.)}">
													<!-- TODO the value should be obtained by the Code -->
													<xsl:value-of select="normalize-space(.)" />
												</datacite:subject>
											</xsl:for-each>
										</datacite:subjects>
										
										<datacite:publisher>
											<xsl:value-of select="normalize-space(//dc:publisher)" />
										</datacite:publisher>
										
										<datacite:publicationYear>
											<xsl:value-of select="normalize-space(//base_dc:year)" />
										</datacite:publicationYear>
										
										<datacite:formats>
											<xsl:for-each select="//dc:format">
												<datacite:format>
													<xsl:value-of select="normalize-space(.)" />
												</datacite:format>
											</xsl:for-each>
										</datacite:formats>
										
										<!-- TODO : TO CONVERT FROM HERE -->

										<dc:type>
											<xsl:value-of select="$varBaseNormType" />
										</dc:type>
										<xsl:call-template name="allElements">
											<xsl:with-param name="sourceElement" select="//dc:type" />
											<xsl:with-param name="targetElement" select="'dc:type'" />
										</xsl:call-template>


										<xsl:call-template name="allElements">
											<xsl:with-param name="sourceElement" select="//dc:source" />
											<xsl:with-param name="targetElement" select="'dc:source'" />
										</xsl:call-template>

										<dc:language>
											<xsl:value-of select="vocabulary:clean( //base_dc:lang, 'dnet:languages')" />
										</dc:language>

										<xsl:call-template name="allElements">
											<xsl:with-param name="sourceElement" select="//dc:rights" />
											<xsl:with-param name="targetElement" select="'dc:rights'" />
										</xsl:call-template>

										<xsl:call-template name="allElements">
											<xsl:with-param name="sourceElement" select="//dc:relation" />
											<xsl:with-param name="targetElement" select="'dc:relation'" />
										</xsl:call-template>

										<xsl:call-template name="allElements">
											<xsl:with-param name="sourceElement" select="//dc:identifier[starts-with(., 'http')]" />
											<xsl:with-param name="targetElement" select="'dc:identifier'" />
										</xsl:call-template>

										<xsl:for-each select="//dc:relation">
											<xsl:if test="matches(normalize-space(.), '(info:eu-repo/grantagreement/ec/fp7/)(\d\d\d\d\d\d)(.*)', 'i')">
												<oaf:projectid>
													<xsl:value-of select="concat($varFP7, replace(normalize-space(.), '(info:eu-repo/grantagreement/ec/fp7/)(\d\d\d\d\d\d)(.*)', '$2', 'i'))" />
												</oaf:projectid>
											</xsl:if>
											<xsl:if test="matches(normalize-space(.), '(info:eu-repo/grantagreement/ec/h2020/)(\d\d\d\d\d\d)(.*)', 'i')">
												<oaf:projectid>
													<xsl:value-of select="concat($varH2020, replace(normalize-space(.), '(info:eu-repo/grantagreement/ec/h2020/)(\d\d\d\d\d\d)(.*)', '$2', 'i'))" />
												</oaf:projectid>
											</xsl:if>
										</xsl:for-each>

									</datacite:resource>

									<dr:CobjCategory>
										<xsl:variable name="varCobjCategory" select="vocabulary:clean($varBaseNormType, 'dnet:publication_resource')" />
										<xsl:variable name="varSuperType" select="vocabulary:clean($varCobjCategory, 'dnet:result_typologies')" />
										<xsl:attribute name="type" select="$varSuperType" />
										<xsl:value-of select="$varCobjCategory" />
									</dr:CobjCategory>

									<oaf:accessrights>
										<xsl:choose>
											<xsl:when test="//base_dc:oa[.='1']">
												OPEN
											</xsl:when>
											<xsl:when test="//base_dc:rightsnorm">
												<xsl:value-of select="vocabulary:clean(//base_dc:rightsnorm, 'dnet:access_modes')" />
											</xsl:when>
											<xsl:when test="//dc:rights">
												<xsl:value-of select="vocabulary:clean( //dc:rights, 'dnet:access_modes')" />
											</xsl:when>
											<xsl:otherwise>
												UNKNOWN
											</xsl:otherwise>
										</xsl:choose>
									</oaf:accessrights>

									<xsl:for-each select="//base_dc:doi">
										<oaf:identifier identifierType="doi">
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>

									<xsl:for-each
										select="distinct-values(//dc:identifier[starts-with(., 'http')][not(contains(., '://dx.doi.org/') or contains(., '://doi.org/') or contains(., '://hdl.handle.net/'))][count(index-of($varIdLdpg, .)) = 0])">
										<oaf:identifier identifierType="url">
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>

									<xsl:for-each select="distinct-values(//dc:identifier[starts-with(., 'http') and contains(., '://hdl.handle.net/')]/substring-after(., 'hdl.handle.net/'))">
										<oaf:identifier identifierType="handle">
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>

									<xsl:for-each select="distinct-values(//dc:identifier[starts-with(., 'urn:nbn:nl:') or starts-with(., 'URN:NBN:NL:')])">
										<oaf:identifier identifierType='urn'>
											<xsl:value-of select="." />
										</oaf:identifier>
									</xsl:for-each>

									<oaf:identifier identifierType="oai-original">
										<xsl:value-of
											select="//*[local-name() = 'about']/*[local-name() = 'provenance']//*[local-name() = 'originDescription' and not(./*[local-name() = 'originDescription'])]/*[local-name() = 'identifier']" />
									</oaf:identifier>

									<oaf:hostedBy>
										<xsl:attribute name="name">
											<xsl:value-of select="//base_dc:collname" />
										</xsl:attribute>
										<xsl:attribute name="id">
											<xsl:value-of select="concat('opendoar____::', //base_dc:collection/@opendoar_id)" />
										</xsl:attribute>
									</oaf:hostedBy>

									<oaf:collectedFrom>
										<xsl:attribute name="name">
											<xsl:value-of select="$varOfficialName" />
										</xsl:attribute>
										<xsl:attribute name="id">
											<xsl:value-of select="$varDataSourceId" />
										</xsl:attribute>
									</oaf:collectedFrom>

									<oaf:dateAccepted>
										<xsl:value-of select="dateCleaner:dateISO( //dc:date[1] )" />
									</oaf:dateAccepted>

									<xsl:if test="//dc:relation[starts-with(., 'http')] and //base_dc:oa[.='1']">
										<oaf:fulltext>
											<xsl:value-of select="//dc:relation[starts-with(., 'http')]" />
										</oaf:fulltext>
									</xsl:if>

									<xsl:for-each select="//base_dc:collection/@ror_id">
										<oaf:relation relType="resultOrganization" subRelType="affiliation" relClass="hasAuthorInstitution" targetType="organization">
											<xsl:choose>
												<xsl:when test="contains(.,'https://ror.org/')">
													<xsl:value-of select="concat('ror_________::', normalize-space(.))" />
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="concat('ror_________::https://ror.org/', normalize-space(.))" />
												</xsl:otherwise>
											</xsl:choose>
										</oaf:relation>
									</xsl:for-each>
								</metadata>
								<xsl:copy-of select="//*[local-name() = 'about']" />
							</record>
						</xsl:template>

						<xsl:template match="//*[local-name() = 'header']">
							<xsl:if test="//oai:header/@status='deleted'">
								<xsl:call-template name="terminate" />
							</xsl:if>
							<xsl:copy>
								<xsl:apply-templates select="node()|@*" />
								<xsl:element name="dr:dateOfTransformation">
									<xsl:value-of select="$transDate" />
								</xsl:element>
							</xsl:copy>
						</xsl:template>

						<xsl:template match="node()|@*">
							<xsl:copy>
								<xsl:apply-templates select="node()|@*" />
							</xsl:copy>
						</xsl:template>
					</xsl:stylesheet>
				</CODE>
			</SCRIPT>
		</CONFIGURATION>
		<STATUS />
		<SECURITY_PARAMETERS />
	</BODY>
</RESOURCE_PROFILE>